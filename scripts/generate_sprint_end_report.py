#!/usr/bin/env python3
"""Generate Sprint-End Code Quality Report.

This script generates a markdown report summarizing code quality metrics
for sprint-end reviews. Used by the code-quality-sprint-end.yml workflow.

Usage:
    python scripts/generate_sprint_end_report.py \
        --sprint 115 \
        --complexity 5 \
        --maintainability 85.5 \
        --duplicates 0 \
        --dead-code 10 \
        --todos 25 \
        --fixmes 3 \
        --security-high 0 \
        --security-medium 2 \
        --dep-vulns 1 \
        --coverage 82.5 \
        --loc 45000 \
        --test-loc 15000 \
        --output docs/sprints/SPRINT_115_CODE_QUALITY_REPORT.md
"""

import argparse
from datetime import datetime
from pathlib import Path


def generate_report(args: argparse.Namespace) -> str:
    """Generate the sprint-end code quality report."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sprint = args.sprint if args.sprint != "auto" else "Unknown"

    # Calculate test/code ratio
    try:
        test_ratio = float(args.test_loc) / float(args.loc) if float(args.loc) > 0 else 0
    except (ValueError, ZeroDivisionError):
        test_ratio = 0

    # Determine overall status
    issues = []
    if args.complexity and int(args.complexity) > 20:
        issues.append(f"High complexity functions: {args.complexity}")
    if args.security_high and int(args.security_high) > 0:
        issues.append(f"High-severity security issues: {args.security_high}")
    if args.coverage:
        try:
            coverage_val = float(args.coverage)
            if coverage_val < 80:
                issues.append(f"Coverage below 80%: {coverage_val:.1f}%")
        except ValueError:
            pass

    status = "PASSED" if not issues else "NEEDS ATTENTION"
    status_emoji = "✅" if not issues else "⚠️"

    report = f"""# Sprint {sprint} Code Quality Report

Generated: {timestamp}

## Summary

| Metric | Value | Status |
|--------|-------|--------|
| Overall Status | {status} | {status_emoji} |
| Test Coverage | {args.coverage or 'N/A'}% | {'✅' if args.coverage and float(args.coverage) >= 80 else '⚠️'} |
| High Complexity Functions | {args.complexity or 0} | {'✅' if not args.complexity or int(args.complexity) <= 20 else '⚠️'} |
| Security Issues (High) | {args.security_high or 0} | {'✅' if not args.security_high or int(args.security_high) == 0 else '❌'} |

## Detailed Metrics

### Code Complexity
- **High complexity functions (CC > 10):** {args.complexity or 'N/A'}
- **Average Maintainability Index:** {args.maintainability or 'N/A'}

### Code Quality
- **Code duplications:** {args.duplicates or 0}
- **Potential dead code items:** {args.dead_code or 0}
- **TODOs:** {args.todos or 0}
- **FIXMEs:** {args.fixmes or 0}

### Security
- **High-severity issues:** {args.security_high or 0}
- **Medium-severity issues:** {args.security_medium or 0}
- **Dependency vulnerabilities:** {args.dep_vulns or 0}

### Size Metrics
- **Source LOC:** {args.loc or 'N/A'}
- **Test LOC:** {args.test_loc or 'N/A'}
- **Test/Code Ratio:** {test_ratio:.2f}

## Recommendations

"""

    # Add recommendations based on metrics
    recommendations = []

    if args.complexity and int(args.complexity) > 10:
        recommendations.append(
            "- **Reduce complexity:** Consider refactoring functions with high cyclomatic complexity"
        )

    if args.dead_code and int(args.dead_code) > 20:
        recommendations.append(
            "- **Remove dead code:** Review and remove unused code identified by vulture"
        )

    if args.todos and int(args.todos) > 30:
        recommendations.append(
            "- **Address TODOs:** Consider converting high-priority TODOs to tracked issues"
        )

    if args.security_high and int(args.security_high) > 0:
        recommendations.append(
            "- **Fix security issues:** Address high-severity security vulnerabilities immediately"
        )

    if args.dep_vulns and int(args.dep_vulns) > 0:
        recommendations.append(
            "- **Update dependencies:** Review and update vulnerable dependencies"
        )

    if test_ratio < 0.3:
        recommendations.append(
            "- **Increase test coverage:** Aim for test/code ratio of at least 0.3"
        )

    if not recommendations:
        recommendations.append("- No critical issues identified. Keep up the good work!")

    report += "\n".join(recommendations)

    report += f"""

---

*Report generated by `scripts/generate_sprint_end_report.py`*
*Sprint {sprint} | AegisRAG Project*
"""

    return report


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Generate Sprint-End Code Quality Report")
    parser.add_argument("--sprint", required=True, help="Sprint number")
    parser.add_argument("--complexity", help="High complexity function count")
    parser.add_argument("--maintainability", help="Average maintainability index")
    parser.add_argument("--duplicates", help="Code duplication count")
    parser.add_argument("--dead-code", help="Dead code item count")
    parser.add_argument("--todos", help="TODO count")
    parser.add_argument("--fixmes", help="FIXME count")
    parser.add_argument("--security-high", help="High-severity security issues")
    parser.add_argument("--security-medium", help="Medium-severity security issues")
    parser.add_argument("--dep-vulns", help="Dependency vulnerabilities")
    parser.add_argument("--coverage", help="Test coverage percentage")
    parser.add_argument("--loc", help="Lines of code")
    parser.add_argument("--test-loc", help="Test lines of code")
    parser.add_argument("--output", required=True, help="Output file path")

    args = parser.parse_args()

    # Generate report
    report = generate_report(args)

    # Write to file
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(report)

    print(f"Report generated: {args.output}")


if __name__ == "__main__":
    main()
